package main

import "fmt"

func main()  {

}

func init()  {
/*
	数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。
	因为长度固定,很少直接使用数组

   数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活

	1、每个成员可以通过索引下标来访问，索引范围0到数组长度减1,len()函数可以获取数组元素个数
	2、默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。

	定义一个数组:
   	var 数组变量名 [元素数量]T

*/

	//1、声明
	var a [3]int             // 0
	fmt.Println(a[0])        // 0

	//2、我们也可以使用数组字面值语法用一组值来初始化数组
	var q [3]int = [3]int{1, 2, 3}
	var r [3]int = [3]int{1, 2}
	fmt.Println(r[2],q) // "0"  [1 2 3]

	//	3、如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算
	f := [...]int{1, 2, 3}
	fmt.Println("%v","%T",f,f)  // [3]int

	/*
		4、数组的长度是数组类型的一个组成部分，[3]int和[4]int是两种不同的数组类型。
			数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。
			长度不一样就无法重新给数组赋值;
		q1 := [3]int{1, 2, 3}
		q1 = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int
		fmt.Printf("%v---%[1]T",q1)

	*/


	/*
		5、上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化
		用key:value 的形式 指定key 值;
	*/
	type Currency int
	const (
		USD Currency = iota // 美元
		EUR                 // 欧元
		GBP                 // 英镑
		RMB                 // 人民币
	)
	symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}
	fmt.Println(RMB,symbol[RMB])  // 3 ￥

	/*
		6、初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化
		创建了一个13个元素的数组，最后一个元素值为-1;其他元素都用0来初始化
	*/
	ar:=[...]int{12:-1}
	fmt.Println(ar)  // [0 0 0 0 0 0 0 0 0 0 0 0 -1]

	/*
		7、如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的
			==比较运算符来比较两个数组
			只有当两个数组的所有元素都是相等的时候数组才是相等的
			不相等比较运算符!=遵循同样的规则
	*/
	aa := [2]int{1, 2}
	bb := [...]int{1, 2}
	cc := [2]int{1, 3}
	fmt.Println(aa == bb, aa == cc, bb == cc)  // true false false


	/*
		8、数组是值类型
		数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。
		[n]*T 表示指针数组，*[n]T 表示数组指针、

	*/

	/*
		9、多维数组
		Go 语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。
		var 数组变量名 [元素数量][元素数量]T
		a := [3][2]string{
			{"北京", "上海"},
			{"广州", "深圳"},
			{"成都", "重庆"},
		}
	*/




}
